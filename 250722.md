### 오늘부터 미라클 코딩을 시작했다.. 거보자고...

---
# 오늘의 깨달음

## 1. 얕은 복사와 깊은 복사
   - [얕은 복사와 깊은 복사](https://wikidocs.net/16038)

1. (mutable 한 객체의) 얕은 복사

```python
A = [1,2,3]
B = A # 얕은 복사

B = [1,2,3,4]
## B를 변경하면 A도 같이 바뀐다.
## A = [1,2,3,4]
```

2. (immutable 한 객체의) 얕은 복사

```python
A = "123"
B = A # 얕은 복사

B = "1234"
## B를 변경해도 A는 바뀌지 않는다.
## A = "123"
```

∴ 백업을 하려는 목적하에, mutable 한 객체는 깊은 복사를 해줘야한다.

```python
import copy
a = [1,2,3]
b = copy.deepcopy(a)

a = [1,2,3,4]
## a를 변경해도 b는 바뀌지 않는다.
## b = [1,2,3]
```
## 2. is 와 == 의 차이
 - 리스트 또는 다른 **가변 객체(mutable)** 를 비교할 때,
    
    **값 자체가 같은지** 확인하려면 `==`를 사용
    
- **두 변수가 완전히 동일한 객체**를 가리키는지를 확인하려면 `is` 사용

## 3. 기타
1) range 함수를 사용할 때의 주의점
    - step이 음수일 때, start 값> stop 값이어야 한다!
2) 연산자의 종류에는 산술연산자, 복합 연산자, 비교 연산자, 논리연산자, 단축연산자, 멤버십 연산자, 시퀀스 연산자, 
3) 싱글턴
4) 거짓 : 0, False, '', [], None
5) 참 : 1, 10, "hello", [1,2] 등 거짓이 아닌 모든 것
6) and 연산자는, 왼쪽에서 오른쪽으로 평가하다가 처음 만나는 거짓 값을 즉시 반환하며, 끝까지 가도 모두 참일 경우에는 맨 마지막 참의 값을 반환한다.
7) or 연산자는 왼쪽에서 오른쪽으로 평가하다가, 처음 만나는 참 값을 즉시 반환하며, 끝까지 가서 모두 거짓이면 맨 마지막 거짓 값을 반환한다.
8) 연산자의 우선순위는 산술>비교>논리 순으로 높다.
9) 인덱싱은 기존의 주소를 참조하고, 슬라이싱은 주소를 새롭게 판다.
10) 자료는 참조형이 있고 원시형이 있는데. 우리가 참조형을 사용하는 이유는 보통--


# WIL

## **1. list**

- (0) 리스트
    - 여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형
        - 숫자, 문자열, 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
        - 값을 추가, 수정, 삭제하는 등 자유롭게 변경할 수 있음
- (1) 시퀀스로서의 리스트
    - 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능
- (2) 중첩 리스트
    - 다른 리스트를 값으로 가진 리스트
    - ** 중첩(Nested) : 어떤 자료 구조 안에 같은 종류의 자료 구조가 포함된 형태
    
    ```python
    my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
    print(my_list[-1][1][0])   # w
    ```
    
- (3) 리스트의 가변성
    - ** 가변성(Mutability) : 생성된 후에도 그 내용(값)을 변경할 수 있는 성질
    - 한번 생성된 리스트는 그 내용을 자유롭게 수정, 추가, 삭제할 수 있다.
    - 문자열의 불변성과는 정반대되는 특징!
    - (예시)
    
    ```python
    my_list = [1, 2, 3, 4, 5]
    my_list[1] = 'two' # [1, 'two', 3, 4, 5]
    
    my_list = [1, 2, 3, 4, 5]
    my_list[2:4] = ['three', 'four']  # [1, 2, 'three', 'four', 5]
    ```
    

## **2. tuple**똑같은 값은 단 하나만 존재할 수 있음

- (0) 튜플
    - 여러 개의 값을 순서대로 저장하는 변경 불가능한 시퀀스 자료
    - 모든 종류의 데이터를 담을 수 있음
    - 리스트와 거의 모든 면에서 비슷하지만, 한 번 만들어지면 절대 수정할 수 없다는 결정적인 차이가 있음
    - 소괄호 없이도 만들 수 있습니다.
    - 단일 요소 튜플을 만들 때는 반드시 Trailing Comma(후행 쉼표)를 사용해야 합니다.
    
    ```python
    my tuple_1 = (1)    # 그냥 1
    my tuple_2 = (1,)   # 튜플 1
    my tuple_3 = 1,'hello',3.14, True # 튜플 ㅇㅇ
    ```
    
- (1) 시퀀스로서의 튜플
    - 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능
- (2) 튜플의 불변성
    - 한 번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제할 수 없음
    - 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용됨
    - 다중 할당, 값 교환, 함수 다중 반환 값 등
    - 개발자가 직접적으로 사용하는 데이터 타입은 아님, 파이썬이 내부 동작을 시행할 때 쓰는 데이터 타입!
    - → 튜플은 데이터의 ‘안정성과 무결성’을 보장!
    

---

## 3. range

- (0) range
    - 연속된 점수 시퀀스를 생성하는, 변경 불가능한(immutable) 자료형
        - 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용
        - 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 ‘규칙’만 기억하여 메모리를 매우 효율적으로 사용
- (1) range의 기본 구문
    - range()는 1~3개의 매개변수(인자)를 가질 수 있다.
        - `range(start, stop, start)`
        - ** 매개변수 : 함수를 정의할 때, 함수가 받을 값을 나타내는 변수
        - ** 인자 : 함수를 호출할 때, 실제로 전달되는 값
    - range() 매개변수별 특징
        - range(stop)
            - 매개변수가 하나면 stop으로 인식
            - start는 0이, step은 1이 기본값으로 자동 설정
        - range(start, stop)
            - 매개변수가 두 개면 start와 stop으로 인식
            - step은 1이 기본값으로 자동 설정
            - range(2,5) → 2,3,4
        - range(start, stop, step)
            - 모든 매개변수를 직접 지정
        - ** range는 list로 형변환 시에만 내부 값을 확인할 수 있음
        
        ```python
        print(range(5)) #range(0,5)
        print(list(range(5))) #[0,1,2,3,4]
        ```
        
- (2) range의 규칙
    - 값의 범위 규칙
        - stop 값은 생성되는 시퀀스에 절대 포함되지 않음
            
            (stop값 바로 앞에서 시퀀스가 끝남)
            
    - 증가/감소 값 규칙
        - step 값은 숫자 시퀀스의 간격과 방향을 결정
        
        ```python
        range(1, 10, 2) # 1, 3, 5, 7, 9
        range(10, 1, -2) # 10, 8, 6, 4, 2
        ```
        
        - step이 음수일 때, start값 > stop 값이어야 함!
    

## 4. dict

- (0) 딕셔너리
    - key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료
    - 값 1개는 키와 값이 쌍으로 이루어져 있음
        - key : 값을 식별하기 위한 고유한 이름표(중복 불가)
        - value : key에 해당하는 실제 데이터
    - 각 값에는 순서가 없음
    - 순서가 없는 자료형이라는 점과 key를 통해 접근한다는 점이 핵심!!
- (1) 딕셔너리 규칙
    - key의 규칙
        - 고유ㅇ중복 X
        - 변경 불가능한 자료형만 사용 가능
            - ㅇ : str, int, float, tuple
            - X : list, dict
    - value의 규칙
        - 없어, freeee~~~~
- (2) 딕셔너리 값 접근
    - key를 사용하여 해당 value를 꺼내올 수 있음
    - key에 접근 시 대괄호 [] 사용
        
        ```python
        my_dict = {'name' : '홍길동', 'age' : 25}
        
        print(my_dict['name']) # '홍길동'
        print(my_dict['test']) # KeyError : 'test'
        ```
        
    - 존재하지 않는 Key로 접근하면 KeyError가 발생하며 프로그램이 멈춤
    - 값의 추가와 변경
        
        ```python
        my_dict = {'apple': 12, 'list': [1, 2, 3]}
        
        # 추가
        my_dict['banana'] = 50
        print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}
        
        # 변경
        my_dict['apple'] = 100
        print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
        ```
        
    - 활용
        - 데이터에순서가 필요없고, 각 데이터에 의미 있는 이름(key)을 붙여 관리하고 싶을 때 사용
        - 예 : 사람의 인적 정보, 게임 캐릭터의 능력치 등
        
        ---
        

## 5. 세트의 집합 연산

- (0) set
    - 순서와 중복이 없는 변경 가능한 자료
    - 예 `{1,2,3}`
    - 세트의 두 가지 핵심 특징
        1. 중복을 허용하지 않음
            - 똑같은 값은 단 하나만 존재할 수 있음
        2. 순서가 없음
            - 인덱싱 x  슬라이싱 x
    - ** 비어있는 딕셔너리와의 혼동을 피하기 위해, 비어있는 세트는 반드시 set()함수로 만들어야 한다.
        
        ```python
        my_set_0 = set()
        my_set_1 = {1, 2, 3}
        my_set_2 = {3, 6, 9}
        
        # 합집합
        print(my_set_1 | my_set_2)   # {1, 2, 3, 6, 9}
        
        # 차집합
        print(my_set_1 - my_set_2)   # {1, 2}
        
        # 교집합
        print(my_set_1 & my_set_2)   # {3}
        ```
        

## 6. Other Types

- (1) None
    - 파이썬에서 ‘값이 없음’을 표현하는 특별한 데이터 타입’
- (2) Boolean
    - 참(True)과 거짓(False) 단 두 가지 값만 가지는 데이터 타입
    - 프로그램의 흐름을 제어하는 조건문에서 “맞다” 또는 “틀리다”를 판단하는 역할
    - 비교 / 논리 연산의 평가 결과로 활용됨
        
        ```python
        is_active = True
        is_logged_in = False
        
        print(is_active)        # True
        print(is_logged_in)     # False
        print(10 > 5)           # True
        print(10 == 5)          # False
        
        ```
        

## 7. Collection

- (0) collection
    - 여러 개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말
        - 여러 물건을 담는 ‘보관함’과 같으며, 목적에 따라 다양한 종류의 컬렉션을 제공
        - str, list, tuple, range, set, dict 은 모두 collection!!
        - 📋 컬렉션 타입별 특성 정리
            
            
            | 컬렉션명 | 변경 가능 여부 | 순서 존재 여부 |  |
            | --- | --- | --- | --- |
            | `str` | X | O | 시퀀스 |
            | `list` | O | O | ‘’ |
            | `tuple` | X | O | ‘’ |
            | `dict` | O | X | 비시퀀스 |
            | `set` | O | X | ‘’ |
- (1) 불변과 가변
    - 컬렉션 타입은 생성 후 내용을 변경할 수 있는지에 따라 '불변'과 '가변' 으로 나뉨
        
        
        | 구분 | 불변 (Immutable) | 가변 (Mutable) |
        | --- | --- | --- |
        | 특징 | 변경 불가, 안전성, 예측 가능 | 변경 가능, 유연성, 효율성 |
        | 종류 | `str`, `tuple`, `range` | `list`, `dict`, `set` |
    - 가변의 특징의 복사를 할 때 신경을 써줘야하는 요소들이 있음. 각각의 장단이 있다는거~

## 8. 형변환

- (0) 형변환
    - 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
- (1) 암시적 형변환 : 파이썬이 자동으로 처리
    - 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것
    - 파이썬이 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙
    
    > “ 더 안전한 쪽으로 ”
    > 
    - (예시) 정수와 실수의 연산에서 정수가 실수로 변환됨
    - Boolean과 Numeric Type에서만 가능
    
    ```python
    # 정수(int)와 실수(float)의 덧셈
    print(3 + 5.0)     # 8.0
    
    # 불리언(bool)과 정수(int)의 덧셈
    print(True + 3)    # 4
    
    # 불리언간의 덧셈
    print(True + False)  # 1
    ```
    
- (2) 명시적 형변환 : 개발자가 직접 지시
    - 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것
    - 서로 다른 타입의 데이터를 ‘호환’되도록 맞추는 과정
    - 형변환 예
        - `int()`
        - `float()`
        - `str()`
        - `list()`
        - `tuple()`
        - `set()`
            
            ```python
            list("abc")    # ['a', 'b', 'c']
            set([1, 2, 2])    # {1, 2}
            ```
            

< 참고 > ← 암기 말고 직접 한번 try 해보세요

### 📘 컬렉션 간 형변환 정리

| From \ To | `str` | `list` | `tuple` | `range` | `set` | `dict` |
| --- | --- | --- | --- | --- | --- | --- |
| `str` | - | O | O | X | O | X |
| `list` | O | - | O | X | O | X |
| `tuple` | O | O | - | X | O | X |
| `range` | O | O | O | - | O | X |
| `set` | O | O | O | X | - | X |
| `dict` | O | O (key만) | O (key만) | X | O (key만) | - |

## 9. 연산자

- (1) 산술 연산자
    - 수학적 계산을 위해 사용되는 연산자
        
        
        | 기호 | 연산자 설명 |
        | --- | --- |
        | `-` | 음수 부호 |
        | `+` | 덧셈 |
        | `-` | 뺄셈 |
        | `*` | 곱셈 |
        | `/` | 나눗셈 (실수 나눗셈) |
        | `//` | 정수 나눗셈 (몫) |
        | `%` | 나머지 |
        | `**` | 지수 (거듭제곱) |
- (2) 복합 연산자
    - 연산과 할당이 함께 이뤄짐
        
        
        | 기호 | 예시 | 의미 |
        | --- | --- | --- |
        | `+=` | `a += b` | `a = a + b` |
        | `-=` | `a -= b` | `a = a - b` |
        | `*=` | `a *= b` | `a = a * b` |
        | `/=` | `a /= b` | `a = a / b` |
        | `//=` | `a //= b` | `a = a // b` |
        | `%=` | `a %= b` | `a = a % b` |
        | `**=` | `a **= b` | `a = a ** b` |
- (3) 비교 연산자
    - 두 값을 비교하여 그 관계가 맞는지 틀리는지를 True 또는 False로 반환
        
        
        | 기호 | 내용 |
        | --- | --- |
        | `<` | 미만 |
        | `<=` | 이하 |
        | `>` | 초과 |
        | `>=` | 이상 |
        | `==` | 같음 |
        | `!=` | 같지 않음 |
        | `is` | 같음 (객체 동일성) |
        | `is not` | 같지 않음 (객체 동일성) |
    - ==           vs             is
        
        
        | 항목 | `==` 연산자 | `is` 연산자 |
        | --- | --- | --- |
        | 비교 대상 | 값 (데이터의 내용) | 객체 자체 (메모리 주소) |
        | 의미 | 동등성 (equality) | 식별성 (identity) |
        | 사용 목적 | 두 값이 **같은 내용인지** 확인 | 두 객체가 **완전히 동일한 객체인지** 확인 |
        | 사용 예시 | `1 == True` → `True` | `1 is True` → `False` |
        | 사용 가능한 타입 | 대부분의 데이터 타입 | 같은 객체를 참조하는지 확인할 때 사용 |
        | 주의 사항 | 값이 같으면 True 반환 | **값이 같아도** 객체가 다르면 False |
    - ⇒ `is` 대신 `==`를 사용해야!!
        - why?
            
            `is`는 **정체성(identity)** 을,
            
            `==`는 **값(value)** 을 비교하기 때문
            
        - 즉,
            
            우리가 정말 궁금한 것은
            
            **"두 객체의 값이 논리적으로 같은가?"**
            
            이므로 `==`를 사용해야 의도에 맞는 `True`를 얻을 수 있음.
            
            - `is` 는  두 변수가 **완전히 동일한 메모리 주소의 객체**를 가리키는지, 즉 **정체성(identity)** 이 같은지를 확인하고
            - `==`는 두 변수가 가리키는 객체의 **내용**, 즉 **값(value)** 이 같은지를 확인함
    - `is` 연산자는 언제 사용하는가 ? : 주로 싱글턴 객체를 비교할 때 사용함
        - ** 싱글턴(singleton) 객체란?
            - 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체
            - 여러 변수가 이 값을 가지더라도, 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐
            - 파이썬의 대표적인 싱글턴 객체 : `None`, `True`, `False`
        - 싱글턴 객체를 비교할 때
            - `is` 연산자는 두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용
            - 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 싱글턴 객체 비교에 적합
            
            ```python
            x = None
            
            # 권장
            if x is None:
                print('x는 None입니다.')
            
            # 비권장
            if x == None:
                print('x는 None입니다.')
            ```
            
    - 결론!!!!!!!
        - 리스트 또는 다른 **가변 객체(mutable)** 를 비교할 때,
            
            **값 자체가 같은지** 확인하려면 `==`를 사용
            
        - **두 변수가 완전히 동일한 객체**를 가리키는지를 확인하려면 `is` 사용
    
    ---
    
    ```python
    a = [1, 2, 3]
    b = [1, 2, 3]
    
    print(a == b)  # True  (두 리스트의 **값**은 동일)
    print(a is b)  # False (서로 **다른 객체**)
    
    # b가 a를 그대로 참조하도록 할 경우
    b = a
    print(a is b)  # True  (같은 객체를 가리킴)
    ```
    
    - **값 비교**에는 `==`를 사용하고, **객체(레퍼런스) 비교**에는 `is`를 사용하는 것이 원칙
        - 숫자나 문자열, 불리언 값 등 **동등성(값)** 을 판단해야 할 때 `is`를 사용하면
            
            의도치 않은 결과 (`False`)가 나올 수 있음
            
            → 이는 파이썬 내부적인 **최적화**나 **타입 차이**로 인해 **일관성**이 깨질 수 있기 때문
            
        - `is`는 주로 **싱글턴 객체**에 대한 비교 시 사용
            
            (예: `None`, `True`, `False` 등)
            
- (4) 논리 연산자
    - 여러 개의 조건을 조합하거나, True / False 값을 반대로 뒤집을 때 사용
        
        
        | 기호 | 연산자 | 내용 |
        | --- | --- | --- |
        | `and` | 논리곱 | 두 피연산자 모두 `True`인 경우에만 전체 표현식을 `True`로 평가 |
        | `or` | 논리합 | 두 피연산자 중 하나라도 `True`인 경우 전체 표현식을 `True`로 평가 |
        | `not` | 논리부정 | 단일 피연산자를 부정 |
    - 논리 연산자 활용
        
        ```python
        print(True and False)   # False
        print(True or False)    # True
        print(not True)         # False
        print(not 0)            # True
        ```
        
    - 비교 연산자와 함께 사용
        
        ```python
        name = 'Alice'
        age = 25
        result = (name == 'Alice') or (age == 30)
        print(result)           # True
        ```
        
- (5) 단축 연산자
    - 단축 평가
        - 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
        - 결과가 이미 정해졌다면 굳이 뒤에 있는 코드까지 확인하지 않음
        - why? 코드 실행을 최적화하고, 불필요한 연산을 피하게 하기 위해!
        - 단순히 T/F  논리 연산을 넘어, 코드의 흐름을 제어하고, 오류를 방지하며, 간결한 코드를 작성하는 데 매우 유용하게 사용되는 파이썬의 중요한 기능
    - ** 파이썬이 어떤 값을 참으로 보고 어떤 값을 거짓으로 보는가?
        - 거짓
            - `False`, 숫자 `0`, 빈 문자열 `""`, 빈 리스트 `[]`, `None` 등
            - → `'비어있거나 없다'`는 느낌의 값들
        - 참
            - `True` 그리고 **'거짓'이 아닌 모든 값**
            - 예: `1`, `10`, `"hello"`, `[1, 2]` 등 **내용이 있는 값**
    - 정리
    - `and` 연산자
        - 하나라도 `'거짓'`이면 **바로 '거짓' 반환**
        - 왼쪽에서 오른쪽으로 평가하다가, 처음 만나는 `'거짓'` 값을 **즉시 반환**
        - 끝까지 가서 모두 `'참'`이면, **맨 마지막 '참' 값 반환**
            
            ```python
            item1 =
            item2 = 
            
            result = item1 and item2
            
            print(result)
            ```
            
            | item1 | item2 | 최종 결과 |
            | --- | --- | --- |
            | `'지도'` | `'나침반'` | `'나침반'` (둘 다 참, 마지막 반환) |
            | `'지도'` | `''` | `''` (두 번째 값이 거짓, 반환) |
            | `''` | `'나침반'` | `''` (첫 번째 값이 거짓, 반환) |
    - `or` 연산자
    - 하나라도 `'참'`이면 **바로 '참' 반환**
    - 왼쪽에서 오른쪽으로 평가하다가, 처음 만나는 `'참'` 값을 **즉시 반환**
    - 끝까지 가서 모두 `'거짓'`이면, **맨 마지막 '거짓' 값 반환**

---

- (6) 멤버십 연산자
    - 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
        
        
        | 연산자 | 설명 |
        | --- | --- |
        | `in` | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 **속하는지** 확인 |
        | `not in` | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 **속하지 않는지** 확인 |
    - `print('h' in 'hello') #True`

---

- (7) 시퀀스 연산자
    
    
    | 연산자 | 내용 |
    | --- | --- |
    | `+` | 결합 연산자 |
    | `*` | 반복 연산자 |

---

- (8) 연산자 우선순위
    
    
    | 우선순위 | 연산자 | 내용 |
    | --- | --- | --- |
    | 높음 | `()` | 소괄호 grouping |
    |  | `[]` | 인덱싱, 슬라이싱 |
    |  | `**` | 거듭제곱 |
    |  | `+`, `-` | 단항 연산자 (양수/음수) |
    |  | `*`, `/`, `//`, `%` | 산술 연산자 |
    |  | `+`, `-` | 산술 연산자 |
    |  | `<`, `<=`, `>`, `>=`, `==`, `!=` | 비교 연산자 |
    |  | `is`, `is not` | 객체 비교 |
    |  | `in`, `not in` | 멤버십 연산자 |
    |  | `not` | 논리 부정 |
    |  | `and` | 논리 AND |
    | 낮음 | `or` | 논리 OR |

## 10. 참고

- Trailing Comma
    - 컬렉션의 마지막 요소 뒤에 붙는 쉼표
        - 일반적으로 선택사항이나, 하나의 요소로 구성된 튜플을 만들 때는 필수
    - 기본 규칙
        - 각 요소를 **별도의 줄**에 작성
        - **마지막 요소 뒤에도 쉼표(,)를 붙임**
        - 닫는 괄호(`]`, `}`)는 **새로운 줄**에 배치
            
            ```python
            # ✅ Good: 여러 줄에 걸쳐 작성 시, trailing comma 사용 권장
            
            items = [
                'item1',
                'item2',
            ]
            
            # Bad: 한 줄에 trailing comma 사용 → 가독성 저하, 스타일 위반
            
            items = ['item1', 'item2',]
            
            # 참고: 한 줄로 작성할 경우 trailing comma는 생략하는 것이 원칙
            
            items = ['item1', 'item2']
            ```
            
    - 장점
        1. **가독성 향상**
            - 각 줄이 동일한 패턴을 가짐
            - 코드 리뷰가 용이함
        2. **유지보수 용이성**
            - 항목 추가/제거가 간단
            - 실수로 인한 구문 오류 방지


# 확인 문제

1. ppl
2. d)
3. b) olleh
4. d
5. b)
6. c) int
7. c)
8. b)
9. ~~a)~~ b) 
    
    or 연산자는 앞의 값이 False로 평가되면 뒤의 값을 반환. 0은 False로 간주되므로 5가 출력
    
10. c)
